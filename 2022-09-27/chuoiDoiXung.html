<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kiểm tra chuỗi đối xứng</title>
  <style>
    pre{
      color:darkred;
    }
  </style>
</head>
<body>
<pre>
  Mô tả bài toán
Xây dựng chương trình sử dụng đệ quy để kiểm tra một từ có phải là từ đối xứng không. Phương thức kiểm tra chuỗi đối xứng có nguyên mẫu như sau:

function isPalindrome(s) ;
Phương thức isPalindrome() trả về true nếu chuỗi truyền vào là chuỗi đối xứng. Còn lại trả về false.

Để hoàn thành bài thực hành, học viên cần:

Đưa mã nguồn lên GitHub
Dán link của repository lên phần nộp bài trên CodeGymX
Hướng dẫn
Một chuỗi palindrome là một từ được đọc theo thứ tự xuôi, ngược đều giống nhau. Ví dụ, rotor và redder là các chuỗi palindrome, nhưng motor thì không phải.

Kiểm tra một chuỗi là một palindrome được chia thành hai bài toán con

(1) Kiểm tra xem ký tự đầu tiên và ký tự cuối cùng của chuỗi có bằng nhau.

(2) Bỏ qua hai ký tự đầu và cuối, kiểm tra xem phần còn lại của chuỗi con là một palindrome.

Bài toán con thứ hai (2) giống như vấn đề ban đầu nhưng nhỏ hơn về kích thước.
</pre>
</body>
</html>
<script>
    let s = prompt("Nhập chuỗi");

    isPalindrome(s)?alert("Đối xứng"):alert("K đối xứng");

  function isPalindrome(str){
      //stop là s
      //giá trị s bắt buộc phải giảm dần
      //hàm gọi lại phải truyền 01 chuỗi < s ban đầu
      //tìm công thức chung

      let strFirst = "";
      let strLast = "";

      if(str.length===0||str.length===1)
      {
          return true;
      }else{
          strFirst = str.substr(0, 1);
          strLast = str.substr(str.length - 1, 1);
          if(strFirst!==strLast){
              return false;
          }else{
              return isPalindrome(str.substr(1,str.length-2));
              //s đã bị cắt ngắn dần sau mỗi lần chạy đệ qui và dừng lại khi chuỗi rỗng hoặc chỉ còn 01 kí tự
          }
      }
  }
</script><script>
(function() {
  var ws = new WebSocket('ws://' + window.location.host + 
             '/jb-server-page?reloadMode=RELOAD_ON_SAVE&'+
             'referrer=' + encodeURIComponent(window.location.pathname));
  ws.onmessage = function (msg) {
      if (msg.data === 'reload') {
          window.location.reload();
      }
      if (msg.data.startsWith('update-css ')) {
          var messageId = msg.data.substring(11);
          var links = document.getElementsByTagName('link');
          for (var i = 0; i < links.length; i++) {
              var link = links[i];
              if (link.rel !== 'stylesheet') continue;
              var clonedLink = link.cloneNode(true);
              var newHref = link.href.replace(/(&|\?)jbUpdateLinksId=\d+/, "$1jbUpdateLinksId=" + messageId);
              if (newHref !== link.href) {
                clonedLink.href = newHref;
              }
              else {
                var indexOfQuest = newHref.indexOf('?');
                if (indexOfQuest >= 0) {
                  // to support ?foo#hash 
                  clonedLink.href = newHref.substring(0, indexOfQuest + 1) + 'jbUpdateLinksId=' + messageId + '&' + 
                                    newHref.substring(indexOfQuest + 1);
                }
                else {
                  clonedLink.href += '?' + 'jbUpdateLinksId=' + messageId;
                }
              }
              link.replaceWith(clonedLink);
          }
      }
  };
})();
</script>